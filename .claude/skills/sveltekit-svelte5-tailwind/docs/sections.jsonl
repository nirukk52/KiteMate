{"index":3,"relative_path":"advanced-ssr.md","detailed_summary":"SvelteKit's advanced SSR guide covers universal/server load functions, hooks, and streaming. Learn to fetch data, handle server-only logic, intercept requests, and improve perceived performance with streaming promises.","sections":[{"heading":"Load Functions","level":2,"offset":16,"limit":188,"summary":"SvelteKit offers two types of load functions: Universal load (`+page.js`, `+layout.js`) runs on both server and client for tasks like fetching public data, while Server load (`+page.server.js`, `+layout.server.js`) runs exclusively on the server for secure operations like database access. Both provide access to route parameters and a `fetch` function, with server load functions additionally offering access to server-specific context like cookies and environment variables."},{"heading":"Streaming","level":2,"offset":204,"limit":98,"summary":"Streaming allows SvelteKit to send data to the browser incrementally, improving perceived performance by rendering parts of the page as they become available. This is achieved by returning unawaited Promises from `load` functions and using the `{#await}` block in Svelte components, but requires careful handling of promise rejections and awareness of platform limitations."},{"heading":"Hooks","level":2,"offset":302,"limit":270,"summary":"Server hooks in SvelteKit, defined in `src/hooks.server.js`, allow you to intercept and modify requests and responses. The `handle` function intercepts every request, while `handleFetch` modifies server-side fetch requests, and `handleError` manages unexpected errors."},{"heading":"Authentication Patterns","level":2,"offset":572,"limit":84,"summary":"This documentation section outlines common authentication patterns in SvelteKit, including server-side session management and shared authentication logic for protecting routes. It also demonstrates how to implement JWT authentication by verifying tokens stored in cookies."},{"heading":"Caching Strategies","level":2,"offset":656,"limit":63,"summary":"This documentation section explains how to implement caching strategies in your application. It demonstrates setting cache headers for specific durations and using `stale-while-revalidate` for improved performance, as well as conditional caching based on response status and ETag support for efficient cache validation."},{"heading":"Error Handling","level":2,"offset":719,"limit":53,"summary":"This documentation section explains how to handle expected errors in SvelteKit by using the `error` function, which can optionally include custom data. Unexpected errors are automatically managed by the `handleError` hook."},{"heading":"Load Invalidation","level":2,"offset":772,"limit":57,"summary":"This documentation section explains how to invalidate cached data in SvelteKit to ensure users see the latest information. You can manually invalidate specific data by URL or all data, or leverage dependency tracking to automatically re-run load functions when underlying data changes. Conditional invalidation allows for more granular control over when data is refreshed."},{"heading":"Performance Optimization","level":2,"offset":829,"limit":51,"summary":"This documentation section explains how to optimize SvelteKit application performance by leveraging parallel load functions, preloading data for faster navigation, and avoiding sequential data fetching waterfalls. By implementing these strategies, developers can significantly improve the user experience and application responsiveness."},{"heading":"Advanced Patterns","level":2,"offset":880,"limit":36,"summary":"SvelteKit offers advanced patterns like automatic request deduplication for identical fetch calls and conditional Server-Side Rendering (SSR) or prerendering, allowing developers to control rendering behavior on a per-route basis. This enables optimizations such as preventing redundant network requests and choosing between client-side only rendering or hybrid approaches for different parts of an application."}]}
{"index":1,"relative_path":"adapters-reference.md","detailed_summary":"SvelteKit adapters transform your app for deployment. `adapter-auto` detects your platform. `adapter-node` creates a Node.js server. `adapter-static` generates a static site.","sections":[{"heading":"Overview","level":2,"offset":16,"limit":4,"summary":"Adapters are plugins for SvelteKit that optimize your built application for specific deployment platforms. They manage server-side rendering, static generation, and platform-specific optimizations to ensure your app runs efficiently wherever it's deployed."},{"heading":"adapter-auto","level":2,"offset":20,"limit":71,"summary":"The `adapter-auto` is a zero-configuration SvelteKit adapter that automatically detects your deployment platform and selects the appropriate adapter for you. While convenient for quick prototyping and standard deployments, it's not suitable for platform-specific configurations or advanced adapter options, and it's recommended to install a specific adapter manually for those cases."},{"heading":"adapter-node","level":2,"offset":91,"limit":275,"summary":"The `@sveltejs/adapter-node` package generates a standalone Node.js server for your SvelteKit application, allowing for easy deployment. It offers configuration options for server behavior, request handling, and resource limits, along with support for graceful shutdown and systemd socket activation."},{"heading":"adapter-static","level":2,"offset":366,"limit":192,"summary":"The `adapter-static` package generates a static site from your SvelteKit application, allowing for deployment to various hosting platforms. It offers configuration options for output directories, fallback pages for SPA mode, and prerendering behavior, with specific examples provided for GitHub Pages and Netlify deployments."},{"heading":"adapter-vercel","level":2,"offset":558,"limit":99,"summary":"The `adapter-vercel` is an optimized adapter for deploying SvelteKit applications to Vercel. It offers configuration options for the Edge Runtime, Incremental Static Regeneration (ISR), and function splitting, allowing for fine-tuned deployment strategies."},{"heading":"adapter-cloudflare","level":2,"offset":657,"limit":71,"summary":"The `@sveltejs/adapter-cloudflare` package allows SvelteKit applications to be deployed to Cloudflare Pages and Workers. It provides configuration options and enables access to Cloudflare-specific features like KV namespaces and Durable Objects through the `platform` context."},{"heading":"adapter-netlify","level":2,"offset":728,"limit":44,"summary":"The `adapter-netlify` is used to deploy SvelteKit applications to Netlify. It can be configured to use Netlify's edge functions and supports Netlify Forms through a simple HTML attribute."},{"heading":"Platform Comparison","level":2,"offset":772,"limit":12,"summary":"This documentation section compares various platforms (Node, Static, Vercel, Cloudflare, Netlify) based on features like SSR, SSG, Edge Runtime, and file system access. It highlights that Node offers the most flexibility with custom servers and full file system access, while platforms like Vercel, Cloudflare, and Netlify excel in modern features like Edge Runtime and streaming."},{"heading":"Writing Custom Adapters","level":2,"offset":784,"limit":67,"summary":"This documentation section explains how to write custom adapters for a build process. Custom adapters are JavaScript functions that return an object with a `name` and an `adapt` method, which uses a `builder` API to perform actions like cleaning directories, writing files, copying assets, and generating manifests."},{"heading":"Deployment Checklist","level":2,"offset":851,"limit":37,"summary":"This documentation section provides a comprehensive checklist for deploying an application, covering pre-deployment steps, platform-specific configurations for Node.js, static sites, and cloud platforms like Vercel, Netlify, and Cloudflare. It ensures a smooth and successful deployment by guiding users through essential checks and settings."}]}
{"index":2,"relative_path":"advanced-routing.md","detailed_summary":"SvelteKit 2.x advanced routing covers rest parameters (`[...file]`), optional parameters (`[[lang]]`), custom matchers for validation, and route sorting. It also details layout groups `(app)` and breaking out of layouts using `@`.","sections":[{"heading":"Rest Parameters","level":2,"offset":16,"limit":81,"summary":"Rest parameters in SvelteKit allow you to capture an unknown number of path segments, represented by `[...paramName]`. This feature is useful for dynamic routing, such as matching file paths or handling nested structures, and can also be used to create custom 404 error pages for specific route segments."},{"heading":"Optional Parameters","level":2,"offset":97,"limit":49,"summary":"This documentation explains how to create optional route segments in SvelteKit by wrapping them in double brackets, allowing for both the presence and absence of a segment. It also covers how to use multiple optional parameters and optional parameters with custom matchers, while warning against invalid combinations like optional parameters following rest parameters."},{"heading":"Matchers","level":2,"offset":146,"limit":92,"summary":"Matchers allow you to define custom validation logic for route parameters, ensuring they meet specific criteria before a route is matched. These synchronous, fast functions can be created for various data types like integers, UUIDs, dates, or enums, and are executed on both the client and server."},{"heading":"Route Sorting","level":2,"offset":238,"limit":49,"summary":"SvelteKit prioritizes matching routes to a URL based on specificity, then the presence of matchers, followed by parameter types, and finally alphabetical order. Layouts with optional parameters do not influence route sorting."},{"heading":"Advanced Layouts","level":2,"offset":287,"limit":120,"summary":"This documentation section explains how to manage complex application layouts using route groups and layout breaking. Route groups, defined by `(name)` directories, allow for shared layouts without affecting URLs, while the `@` symbol enables pages or layouts to selectively inherit from specific parent layout levels or reset to the root."},{"heading":"Character Encoding","level":2,"offset":407,"limit":69,"summary":"This documentation explains how to use special characters in routes by encoding them. You can use hexadecimal encoding `[x+nn]` for common special characters and Unicode encoding `[u+nnnn]` for emojis and other Unicode characters, especially when file systems have limitations."},{"heading":"Advanced Routing Patterns","level":2,"offset":476,"limit":99,"summary":"This documentation section explores advanced routing patterns in SvelteKit, including catch-all routes with validation, nested optional parameters, dynamic layouts using route groups, parallel routes for different parameter types, and conditional layout inheritance. These patterns offer greater flexibility and control over how your application handles URLs and renders content."},{"heading":"Route Debugging","level":2,"offset":575,"limit":43,"summary":"This documentation section explains how to debug routes by checking route matching, logging route parameters in server hooks, and validating route structure within page load functions. These techniques help developers understand how routes are being matched and what parameters are being passed."},{"heading":"Performance Considerations","level":2,"offset":618,"limit":55,"summary":"This documentation section advises on performance by recommending synchronous regex checks over slow database lookups for matchers, organizing routes with specificity rather than excessive catch-alls, and optimizing layouts to minimize re-renders."},{"heading":"Common Patterns","level":2,"offset":673,"limit":63,"summary":"This documentation section outlines common routing patterns for web applications, including how to implement multi-language support, versioned API routes, and an admin dashboard structure. These patterns leverage SvelteKit's file-based routing to organize and manage different application features effectively."}]}
{"index":4,"relative_path":"integration-patterns.md","detailed_summary":"This guide details integrating SvelteKit 2.x, Svelte 5, and Tailwind CSS v4. It covers project setup, configuration, and component/layout patterns using reactive styling and dynamic classes.","sections":[{"heading":"Complete Setup","level":2,"offset":18,"limit":62,"summary":"This section outlines the complete setup for a SvelteKit project with Tailwind CSS v4. It involves initializing the project, installing Tailwind CSS, and configuring Vite, Svelte, and the main CSS file to integrate the styling framework."},{"heading":"Component Patterns","level":2,"offset":80,"limit":191,"summary":"This documentation section demonstrates Svelte component patterns for creating dynamic and reusable UI elements. It showcases reactive styling using `$state` and `$derived` for conditional class application, building reusable components with props, and creating form components with two-way data binding."},{"heading":"Layout Patterns","level":2,"offset":271,"limit":147,"summary":"This documentation section introduces layout patterns for Svelte applications, demonstrating a responsive grid layout for general pages and a dashboard layout with a collapsible sidebar. These examples showcase how to structure common UI elements like headers, navigation, and main content areas to adapt to different screen sizes and application needs."},{"heading":"Form Handling with SvelteKit Actions","level":2,"offset":418,"limit":116,"summary":"SvelteKit Actions allow you to handle form submissions on the server-side within your Svelte components. You can define `actions` in a `+page.server.js` file to process form data, perform validation, and interact with backend services."},{"heading":"Data Loading Patterns","level":2,"offset":534,"limit":108,"summary":"This documentation section describes two data loading patterns: \"Loading with Skeleton UI\" for progressively loading content with placeholder elements, and \"Infinite Scroll\" for fetching more data as the user scrolls down the page. These patterns aim to improve user experience by providing immediate feedback and seamless content delivery."},{"heading":"Dark Mode Integration","level":2,"offset":642,"limit":68,"summary":"This documentation describes how to implement dark mode in a Svelte application using a `ThemeToggle` component. The component manages dark mode state by storing preferences in `localStorage` and toggling a `dark` class on the `documentElement`. The provided example shows how to integrate this `ThemeToggle` into a SvelteKit layout for global dark mode functionality."},{"heading":"Build Optimization","level":2,"offset":710,"limit":49,"summary":"This documentation section outlines build optimization strategies for SvelteKit projects. It demonstrates how to configure Vite for production builds, including enabling CSS optimization and disabling sourcemaps, and illustrates code splitting techniques by lazily loading a heavy charting library."},{"heading":"Deployment Patterns","level":2,"offset":759,"limit":40,"summary":"This documentation section outlines two deployment patterns: environment-specific styling, where CSS variables can be dynamically set based on the environment (e.g., production vs. development), and static export for CDNs, which configures a SvelteKit project to generate static HTML and assets for efficient distribution."},{"heading":"Complete Example: Blog Application","level":2,"offset":799,"limit":31,"summary":"This documentation section presents a complete example of a blog application built with SvelteKit, showcasing full Server-Side Rendering (SSR) and reactive components using Svelte 5 runes. The example integrates utility-first styling with Tailwind CSS v4, an optimized build pipeline, and is production-ready for deployment."}]}
{"index":5,"relative_path":"svelte5-api-reference.md","detailed_summary":"Svelte 5 API reference: new runes like `$state` for reactive state, `$derived` for computed values, and `$effect` for side effects. Covers props, template syntax, and component patterns.","sections":[{"heading":"Core Runes","level":2,"offset":16,"limit":396,"summary":"Svelte 5's \"Core Runes\" are reactive primitives like `$state` for managing mutable state and `$derived` for computed values. `$state` triggers UI updates when changed, supporting deep reactivity and array methods, while `$derived` automatically recalculates based on its dependencies without side effects."},{"heading":"Props Rune","level":2,"offset":412,"limit":107,"summary":"The `$props()` rune in SvelteKit is used to receive and destructure component props, supporting features like fallback values, renaming, rest props, and type safety with TypeScript or JSDoc. The `$bindable()` rune allows props to be two-way bound from a parent component, and `$props.id()` generates unique, SSR-consistent IDs for elements within a component."},{"heading":"Template Syntax","level":2,"offset":519,"limit":86,"summary":"This documentation section outlines Svelte's template syntax, covering how to embed JavaScript expressions, implement conditional logic, iterate over lists with `{#each}`, handle asynchronous operations with `{#await}`, and manage component re-creation using `{#key}` blocks. It also introduces Svelte 5's `{#snippet}` feature for creating reusable template fragments."},{"heading":"Bindings","level":2,"offset":605,"limit":37,"summary":"Svelte's `bind:` directive creates a two-way binding between a variable and an element's property, allowing for automatic synchronization of data. This can be used for form inputs, element properties like dimensions, component props, and even for updating state within functions in Svelte 5."},{"heading":"Lifecycle","level":2,"offset":642,"limit":56,"summary":"Svelte 5 replaces traditional lifecycle functions with runes, utilizing `$state` for initialization and `$effect` (with its `.pre` variant) for managing logic before and after updates, as well as for component destruction and cleanup. The `$effect` rune can also be used to simulate `onMount` behavior by reacting to state changes that indicate the component is in the DOM."},{"heading":"Context API","level":2,"offset":698,"limit":31,"summary":"The Context API in Svelte allows you to pass data down the component tree without explicit prop drilling. You can use `setContext` in a parent component to make data available and `getContext` in a child component to retrieve it, supporting both direct values and reactive functions."},{"heading":"Stores (Legacy Compatibility)","level":2,"offset":729,"limit":20,"summary":"Svelte 5 runes are the new standard, but existing Svelte stores (writable, derived, readable) remain compatible and can be auto-subscribed within components using the `$` prefix. This ensures a smooth transition for projects still utilizing the older store pattern."},{"heading":"Component Communication Patterns","level":2,"offset":749,"limit":53,"summary":"This documentation section outlines common Svelte component communication patterns. It explains how data flows from parent to child via props, how child components can communicate back to their parents using callbacks, and how to achieve two-way data binding between parent and child."},{"heading":"Special Elements","level":2,"offset":802,"limit":86,"summary":"Svelte provides special elements for advanced component features, including recursive rendering with `<svelte:self>`, dynamic rendering of components and HTML elements with `<svelte:component>` and `<svelte:element>`, event listeners on window, document, and body, adding elements to the document head with `<svelte:head>`, and configuring compiler options with `<svelte:options>`. These elements offer powerful ways to build flexible and interactive Svelte applications."},{"heading":"TypeScript Support","level":2,"offset":888,"limit":25,"summary":"This documentation section explains how to leverage TypeScript within Svelte components. It demonstrates how to define component types using `ComponentProps` and how to create generic components that can handle various data types."}]}
{"index":6,"relative_path":"sveltekit-configuration.md","detailed_summary":"SvelteKit config reference: `svelte.config.js` handles core settings, compiler options, preprocessing, and adapters for deployment. `vite.config.js` integrates Vite build tools. TypeScript definitions are auto-generated. Environment variables are managed for static and dynamic access.","sections":[{"heading":"svelte.config.js Structure","level":2,"offset":16,"limit":123,"summary":"The `svelte.config.js` file, located at the project root, is SvelteKit's primary configuration file. It allows for basic setup like specifying an adapter, and offers extensive options for compiler settings, preprocessing, deployment adapters, file paths, and more."},{"heading":"Adapter Configuration","level":2,"offset":139,"limit":192,"summary":"SvelteKit adapters transform your app for deployment by handling platform-specific needs. `adapter-auto` automatically selects the correct adapter, while `adapter-node` is for standalone Node.js servers, and `adapter-static` is for static site generation."},{"heading":"vite.config.js Integration","level":2,"offset":331,"limit":77,"summary":"SvelteKit leverages Vite for its build process, allowing you to extend standard Vite configurations within your `vite.config.js` file. This file enables customization of development server settings, build options, dependency optimization, path resolution, and CSS processing."},{"heading":"TypeScript Configuration","level":2,"offset":408,"limit":49,"summary":"SvelteKit automatically generates TypeScript definitions and provides a `tsconfig.json` file for configuration. You can also define path aliases in `tsconfig.json` to simplify imports, which should be mirrored in your `svelte.config.js`."},{"heading":"Environment Variables","level":2,"offset":457,"limit":32,"summary":"This documentation explains how to use environment variables, categorizing them into static variables replaced at build time and dynamic variables available at runtime. Both types can be accessed in your code and are separated into public and private categories, with private variables only accessible server-side."},{"heading":"Build Configuration","level":2,"offset":489,"limit":40,"summary":"This section outlines how to configure builds for development and production. It details commands for starting a development server with options like custom ports and network exposure, as well as commands for creating a production build and previewing it. The documentation also illustrates the typical output structure of a production build, categorizing assets into client, server, prerendered pages, and a request handler."},{"heading":"Prerendering Configuration","level":2,"offset":529,"limit":46,"summary":"This documentation explains how to configure prerendering in your SvelteKit application to control which pages are generated at build time. You can enable prerendering globally or on a per-route basis, and further customize its behavior through options in `svelte.config.js` like concurrency, crawling, and error handling."},{"heading":"Path Configuration","level":2,"offset":575,"limit":45,"summary":"The Path Configuration section explains how to set a base path for your SvelteKit application, allowing it to be served from a subdirectory. It also details how to use relative paths for static exports, ensuring assets are correctly referenced."},{"heading":"Integration-Specific Configuration","level":2,"offset":620,"limit":56,"summary":"This documentation section outlines integration-specific configurations for SvelteKit with Tailwind CSS, including necessary `svelte.config.js` and `vite.config.js` settings, and how to set up a Content Security Policy (CSP) within SvelteKit. It provides code examples for both Tailwind CSS integration and CSP directives."},{"heading":"Debugging Configuration","level":2,"offset":676,"limit":30,"summary":"This documentation section explains how to configure Vite for debugging. It covers enabling source maps for better debugging in the browser, using verbose logging to get more detailed output from Vite, and performing type checking without a full build."},{"heading":"Common Configuration Patterns","level":2,"offset":706,"limit":54,"summary":"This documentation section outlines common SvelteKit configuration patterns, including setting up a monorepo by specifying custom library paths, configuring for multiple environments with conditional origins and base paths, and defining custom locations for routes, libraries, assets, and app templates. These examples demonstrate how to tailor SvelteKit's build and runtime behavior to different project structures and deployment needs."}]}
{"index":7,"relative_path":"tailwind-configuration.md","detailed_summary":"Tailwind CSS v4 config for SvelteKit. Supports CSS-first or JS config. Covers installation, theme customization, dark mode, plugins, and arbitrary values.","sections":[{"heading":"Installation and Setup","level":2,"offset":16,"limit":42,"summary":"To install Tailwind CSS with Vite and SvelteKit, first run `npm install tailwindcss@next @tailwindcss/vite@next`. Then, configure your `vite.config.js` to include the Tailwind CSS plugin, import `tailwindcss` into your `src/app.css` file, and finally import `app.css` into your root Svelte layout file."},{"heading":"Configuration Approaches","level":2,"offset":58,"limit":46,"summary":"Tailwind v4 provides two configuration methods: a native CSS-first approach using `@theme` and `@plugin` directives, and a JavaScript-based `tailwind.config.js` file for backward compatibility with v3. Both methods allow you to define theme values like colors, fonts, breakpoints, and spacing."},{"heading":"Content Configuration","level":2,"offset":104,"limit":52,"summary":"The Content Configuration section explains how to tell Tailwind CSS where to find your project's HTML, JavaScript, and Svelte files so it can scan for class names. It also covers how to use the `safelist` option to prevent specific classes from being removed during the build process."},{"heading":"Theme Customization","level":2,"offset":156,"limit":68,"summary":"This documentation section explains how to customize themes using CSS variables for properties like colors, fonts, and spacing, and also through JavaScript configuration for extending existing theme properties. This allows for flexible and consistent styling across an application."},{"heading":"Dark Mode Configuration","level":2,"offset":224,"limit":68,"summary":"This documentation section explains how to configure dark mode in your project. It presents three methods: class-based (recommended, using a `dark` class on the `<html>` element), media query-based (leveraging the `prefers-color-scheme` CSS media feature), and selector-based (using a custom data attribute). The class-based approach includes a SvelteKit example demonstrating how to toggle dark mode using local storage and dynamically adding/removing the `dark` class."},{"heading":"Vite Plugin Options","level":2,"offset":292,"limit":33,"summary":"This section explains how to configure Vite plugin options for Tailwind CSS, specifically focusing on Lightning CSS optimization. You can disable optimization entirely in development or selectively disable minification, and enable production optimization based on the environment."},{"heading":"Plugins","level":2,"offset":325,"limit":60,"summary":"This documentation section explains how to use Tailwind CSS plugins, covering both official plugins like `@tailwindcss/forms` and custom plugins defined in CSS or JavaScript. You can install and configure official plugins, or create your own by defining CSS rules or JavaScript functions that add utilities and components."},{"heading":"Custom Utilities","level":2,"offset":385,"limit":24,"summary":"This section explains how to use Tailwind CSS's \"arbitrary values\" feature to apply custom styles directly within your HTML. You can use arbitrary values for properties, selectors, and even entire CSS rules, offering maximum flexibility."},{"heading":"SvelteKit-Specific Configuration","level":2,"offset":409,"limit":91,"summary":"This documentation section explains how to set up SvelteKit with Tailwind CSS, including configuration for Vite and how to handle dynamic class names by providing complete class names or using safelisting. It also demonstrates basic Tailwind usage within Svelte components and CSS files."},{"heading":"Advanced Configuration","level":2,"offset":500,"limit":63,"summary":"This section details advanced Tailwind CSS configuration options, allowing you to customize class prefixes, enforce `!important` declarations, change variant separators, and disable specific core plugins. These settings provide fine-grained control over how Tailwind classes are generated and applied."},{"heading":"PostCSS Configuration","level":2,"offset":563,"limit":31,"summary":"This documentation explains how to configure PostCSS, primarily by defining its plugins. You can set up basic configurations with plugins like Tailwind CSS and Autoprefixer, or include additional plugins like CSSnano conditionally based on the environment."},{"heading":"Performance Optimization","level":2,"offset":594,"limit":40,"summary":"This documentation section outlines performance optimization strategies for a SvelteKit project using Vite and Tailwind CSS. It demonstrates how to enable production optimizations like CSS minification and code splitting, and how to configure Tailwind's content extraction for improved build times."},{"heading":"Migration from v3 to v4","level":2,"offset":634,"limit":52,"summary":"This documentation outlines the migration from Tailwind CSS v3 to v4, highlighting key changes like a CSS-first configuration with `@theme` syntax, the use of a Vite plugin, built-in Lightning CSS optimization, and the default JIT mode. The migration involves updating npm packages, modifying the Vite configuration to use the new plugin, and changing the CSS import syntax."},{"heading":"Environment-Specific Configuration","level":2,"offset":686,"limit":41,"summary":"This documentation section explains how to configure your application differently for development and production environments. It demonstrates using environment variables like `NODE_ENV` to conditionally apply settings, such as optimizing and minifying plugins or changing theme colors."},{"heading":"Troubleshooting","level":2,"offset":727,"limit":30,"summary":"This documentation section provides solutions for common issues encountered when using Tailwind CSS with SvelteKit. It covers troubleshooting steps for problems like classes not applying, build performance, dark mode functionality, and Hot Module Replacement (HMR) not working."}]}
