{"index":2,"relative_path":"common-issues.md","detailed_summary":"Fix SvelteKit 2, Svelte 5, & Tailwind v4 issues: module/import errors, CSS loading, Tailwind processing, and SSR problems. Includes error messages, causes, and solutions.","sections":[{"heading":"Module and Import Errors","level":2,"offset":14,"limit":135,"summary":"This documentation section addresses common module and import errors in SvelteKit projects. It provides solutions for issues like missing Tailwind CSS plugins, incorrect Svelte versions, improper `use:enhance` imports, and problems with `$lib` aliases."},{"heading":"CSS Loading Issues","level":2,"offset":149,"limit":113,"summary":"This documentation section addresses common CSS loading issues in SvelteKit with Tailwind CSS. The primary causes are incorrect Vite plugin order, missing CSS imports in the root layout, or CSS being loaded too late in page components, leading to unstyled content."},{"heading":"Tailwind Processing Errors","level":2,"offset":262,"limit":122,"summary":"Tailwind CSS processing errors often occur when dynamic class names or template literals are used, leading to classes being purged in production. Solutions include using the `class:` directive, safelisting patterns in `tailwind.config.js`, or employing inline styles for dynamic arbitrary values. The `@apply` directive also fails in scoped styles and should be replaced with direct utility class usage or moved to global CSS."},{"heading":"Runes SSR Errors","level":2,"offset":384,"limit":98,"summary":"This documentation section explains common Server-Side Rendering (SSR) errors in Runes, such as `localStorage is not defined` and `document is not defined`, which occur when browser-specific APIs are accessed during server rendering. It provides fixes by guarding such code with a `browser` check from `$app/environment` or by using server-side data loading to ensure consistent rendering between the server and client, preventing hydration mismatches."},{"heading":"Hot Module Reload Problems","level":2,"offset":482,"limit":80,"summary":"This documentation section addresses common Hot Module Reload (HMR) problems in Vite, such as the dev server crashing due to file watching conflicts or the specified port being in use. It provides solutions including configuring Vite's watch options, increasing file watcher limits on macOS/Linux, and managing port conflicts by killing existing processes or configuring Vite to use alternative ports."},{"heading":"TypeScript Configuration Errors","level":2,"offset":562,"limit":56,"summary":"This documentation section addresses common TypeScript errors encountered when using Svelte 5 runes. It provides solutions for \"Cannot find name '$state'\" by checking `tsconfig.json` and ensuring Svelte 5 is installed, and for \"Type 'PageData' does not satisfy constraint\" by using generated types and ensuring type consistency between load functions and components."},{"heading":"Build and Production Errors","level":2,"offset":618,"limit":71,"summary":"This documentation section addresses common build and production errors in SvelteKit. It provides debugging steps for general build failures, such as clearing caches and enabling verbose logging, and specifically tackles \"Prerendering failed\" errors by explaining how to avoid browser API access during prerendering."},{"heading":"Deployment Failures","level":2,"offset":689,"limit":57,"summary":"This documentation section addresses common deployment failures. It provides solutions for the \"Cannot find module './handler.js'\" error by ensuring the correct Svelte adapter is installed and configured, and for \"Environment variables not working\" by emphasizing the use of the `PUBLIC_` prefix for client-accessible variables and proper configuration on the deployment platform."},{"heading":"Quick Troubleshooting Checklist","level":2,"offset":746,"limit":63,"summary":"This documentation section provides a quick troubleshooting checklist for common issues, starting with checking Vite configuration, CSS imports, and clearing caches. It also suggests verifying versions, testing production builds, inspecting browser consoles, and disabling JavaScript to ensure server-side rendering works."}]}
{"index":3,"relative_path":"data-loading.md","detailed_summary":"SvelteKit's load functions fetch data before rendering. Combine server-side loading with Svelte 5 runes for reactive, real-time apps. Choose server-only or universal load functions based on data needs.","sections":[{"heading":"Load Function Fundamentals","level":2,"offset":16,"limit":80,"summary":"Load functions in SvelteKit execute before page rendering to fetch and provide data as props to your components. They are the recommended way to fetch data, ensuring it's available during Server-Side Rendering (SSR) and avoiding client-side fetching issues like Flash of Unstyled Content (FOUC)."},{"heading":"Server vs Client Load Functions","level":2,"offset":96,"limit":71,"summary":"Server load functions (`+page.server.ts`) run exclusively on the server and can access sensitive data like databases and private API keys. Universal load functions (`+page.ts`) run on both the server during SSR and the client during navigation, but lack access to server-only resources."},{"heading":"Passing Data to Rune State","level":2,"offset":167,"limit":104,"summary":"This documentation explains how to pass data from a SvelteKit load function into reactive Svelte 5 state using `$state()`. It emphasizes creating local reactive state from the `data` prop rather than mutating the prop directly, and demonstrates how to achieve deep reactivity with objects and derive new state using `$derived()`."},{"heading":"Reactive Data Patterns","level":2,"offset":271,"limit":133,"summary":"This section introduces reactive data patterns in SvelteKit, demonstrating how to combine load data with runes for real-time user experiences. It covers techniques like optimistic updates, real-time synchronization via polling, dependency tracking for selective data invalidation, and pagination using derived state."},{"heading":"Streaming Data","level":2,"offset":404,"limit":83,"summary":"This documentation explains how to use the streaming pattern to load slow data without blocking page rendering. By returning promises from your `load` function, you can display fast, blocking data immediately while asynchronously loading and rendering slower data as it becomes available."},{"heading":"Error Handling","level":2,"offset":487,"limit":82,"summary":"This documentation section explains how to handle errors gracefully in SvelteKit load functions by throwing specific errors like `404` or using `redirect` for navigation. It also demonstrates how to display these errors to the user using a dedicated error page (`+error.svelte`) and how to handle errors within streaming data."},{"heading":"TypeScript Data Types","level":2,"offset":569,"limit":66,"summary":"This documentation section explains how to define and use TypeScript types in SvelteKit to ensure data is loaded and handled correctly. It demonstrates defining types locally within a page server file and also how to share types across different parts of your application using separate files."},{"heading":"Caching and Invalidation","level":2,"offset":635,"limit":76,"summary":"This documentation explains how to manage caching and invalidation in your application. You can control caching with HTTP headers and manually invalidate specific or all cached data, and also trigger revalidation after mutations or conditionally based on URL parameters."},{"heading":"Common Data Loading Mistakes","level":2,"offset":711,"limit":85,"summary":"This section highlights common data loading mistakes in SvelteKit, such as fetching data in components instead of `load` functions, not using SvelteKit's specialized `fetch`, and creating data fetching waterfalls. It advises using `load` functions, SvelteKit's `fetch`, and `Promise.all` to optimize data loading."}]}
{"index":1,"relative_path":"best-practices.md","detailed_summary":"Best practices for SvelteKit 2 + Svelte 5 + Tailwind v4. Focuses on project organization (route groups), component architecture (size, props, composition), and state management (server/client separation, context, form handling).","sections":[{"heading":"Project Organization","level":2,"offset":17,"limit":83,"summary":"This documentation section recommends a structured directory layout for a project to ensure scalability and maintainability, organizing code by type like components, server logic, and utilities. It also suggests using route groups for shared layouts and access requirements, grouping routes by user flow (e.g., authentication, app, marketing) rather than by feature."},{"heading":"Component Architecture","level":2,"offset":100,"limit":112,"summary":"This documentation section emphasizes building maintainable components by keeping them small (under 150-200 lines), using type-safe `$props()` with defaults, and favoring composition over inheritance. It also provides a responsibility matrix to guide component design based on their intended role."},{"heading":"State Management Strategy","level":2,"offset":212,"limit":107,"summary":"This documentation section outlines strategies for managing state in Svelte applications, emphasizing the use of context for deep state sharing and separating server-rendered data from client-managed state. It also provides patterns for handling form submissions with optimistic UI and error handling, along with decision rules for choosing the appropriate state management approach."},{"heading":"Styling Conventions","level":2,"offset":319,"limit":114,"summary":"This documentation section emphasizes consistent styling through a utility-first approach, component variants for reusable styles, and conditional styling using runes. It also outlines responsive design patterns for layouts, typography, and spacing."},{"heading":"Performance Best Practices","level":2,"offset":433,"limit":140,"summary":"To optimize for production performance, implement code splitting for heavy components, optimize images with responsive loading, preload critical resources like fonts, and use efficient data loading strategies like pagination and deferring non-critical data. Additionally, leverage CSS custom properties and minimize custom CSS, relying on frameworks like Tailwind for styling."},{"heading":"Security Considerations","level":2,"offset":573,"limit":102,"summary":"This section emphasizes securing your application by using environment variables correctly, validating all user inputs on the server-side, and leveraging SvelteKit's built-in CSRF protection and default XSS prevention. It also highlights the importance of sanitizing any HTML content before rendering it with `@html`."},{"heading":"Testing Strategies","level":2,"offset":675,"limit":97,"summary":"This documentation section outlines a comprehensive testing strategy, detailing how to implement unit tests for individual components, integration tests for forms, and end-to-end (E2E) tests using Playwright to ensure application functionality and styling. The examples provided demonstrate testing component props, event handling, form validation, and user flows."},{"heading":"Code Splitting Patterns","level":2,"offset":772,"limit":60,"summary":"This documentation section explains code splitting patterns to optimize bundle sizes in SvelteKit. It covers automatic route-based splitting, manual component-based splitting using dynamic imports, and vendor splitting via Vite configuration."},{"heading":"Accessibility Guidelines","level":2,"offset":832,"limit":71,"summary":"This documentation section outlines accessibility guidelines for building inclusive applications. It emphasizes using semantic HTML elements, ARIA attributes to provide context for assistive technologies, and ensuring proper keyboard navigation for all interactive components."},{"heading":"Production Checklist","level":2,"offset":903,"limit":48,"summary":"This production checklist outlines essential steps to verify before deploying an application, covering performance, security, accessibility, testing, SEO, and monitoring. Following these guidelines ensures a maintainable, performant, and secure application."}]}
{"index":5,"relative_path":"documentation-search-system.md","detailed_summary":"This doc details a multi-stage documentation search system using JSONL indexes. It emphasizes a research-first methodology for skills, guiding users to discover, load, reason about, and read targeted documentation sections for accurate implementation.","sections":[{"heading":"Overview","level":2,"offset":3,"limit":6,"summary":"This document outlines a method for building an efficient, reasoning-based documentation search system using JSONL index files and a multi-stage workflow. The system optimizes token usage and relevance by indexing documentation by section and allowing targeted searches across multiple collections."},{"heading":"How to Implement This System","level":2,"offset":9,"limit":45,"summary":"Skills that bundle indexed documentation should instruct users to perform a multi-stage search of that documentation before implementing any solution. This research-first approach ensures users understand the package's recommended patterns and best practices, leading to better, more maintainable code."},{"heading":"How to Use This Skill","level":2,"offset":54,"limit":92,"summary":"To use this skill, always research the documentation first to understand the recommended approach for a given task with {package-name}. The documentation search process involves discovering available indexes, loading relevant ones, reasoning about candidate files, reading specific sections, and finally synthesizing the information to provide a comprehensive answer."},{"heading":"System Components","level":2,"offset":146,"limit":86,"summary":"The search system utilizes two synchronized JSONL index files: `index.jsonl` for quick, keyword-rich summaries and `sections.jsonl` for detailed file and section-level information. These files maintain a strict 1:1 mapping to enable efficient lookups and support multiple, discoverable documentation collections within a project."},{"heading":"The Multi-Stage Search Workflow","level":2,"offset":232,"limit":238,"summary":"The multi-stage search workflow begins with \"Index Discovery\" (Stage 0), where the system identifies relevant documentation collections by examining their index files. This initial step helps avoid loading unnecessary data and ensures a more targeted search by understanding the scope and topic of each collection."},{"heading":"Summary","level":2,"offset":470,"limit":27,"summary":"This documentation search system prioritizes efficiency and relevance by discovering available collections, using structured indexing, and employing reasoning-based selection and section-level reading. This multi-stage workflow allows for fast, token-efficient, and accurate searches across large documentation sets, mirroring human search behavior."}]}
{"index":6,"relative_path":"forms-and-actions.md","detailed_summary":"SvelteKit form actions enable server-side form processing with progressive enhancement. `use:enhance` integrates client-side behavior, managing reactivity and state for seamless form submissions, loading states, and error handling.","sections":[{"heading":"Form Actions Quick Review","level":2,"offset":16,"limit":82,"summary":"Form actions in SvelteKit allow server-side processing of form submissions without requiring JavaScript. They enable progressive enhancement, ensuring forms function even when JavaScript is disabled."},{"heading":"Progressive Enhancement with Runes","level":2,"offset":98,"limit":62,"summary":"The `use:enhance` directive in SvelteKit allows for progressive enhancement of forms, enabling client-side behavior like no page reloads and loading states while preserving server-side functionality. Customizing `enhance` can be used to maintain specific component states, such as a \"submitting\" flag, across form submissions."},{"heading":"Handling use:enhance Reactivity","level":2,"offset":160,"limit":100,"summary":"The `use:enhance` directive in SvelteKit allows for custom callbacks to intercept form submissions, providing control before and after the request. These callbacks can modify data, cancel submissions, handle results, and update the UI, enabling advanced form behaviors like conditional submissions and real-time feedback."},{"heading":"Optimistic UI Patterns","level":2,"offset":260,"limit":109,"summary":"Optimistic UI patterns involve immediately updating the user interface to reflect an action, such as adding or deleting an item, while the actual request is processed in the background. This provides a more responsive user experience, but it's crucial to handle potential failures by reverting the UI changes if the background request fails."},{"heading":"Validation Strategies","level":2,"offset":369,"limit":149,"summary":"This documentation section emphasizes combining client-side and server-side validation for an optimal user experience. It provides examples of implementing server-side validation using Zod and client-side validation with Svelte runes, including real-time feedback using derived state."},{"heading":"File Uploads with Styling","level":2,"offset":518,"limit":148,"summary":"This documentation section demonstrates how to implement styled file uploads with client-side previews and server-side handling. It includes Svelte code for both the frontend, featuring image previews and simulated progress, and the backend, which validates and saves uploaded image files."},{"heading":"Error Handling and Feedback","level":2,"offset":666,"limit":68,"summary":"This documentation section emphasizes providing clear feedback for all form states, including comprehensive error handling for both individual fields and the entire form. It also demonstrates how to display success messages and a loading indicator during submission."},{"heading":"TypeScript for Forms","level":2,"offset":734,"limit":44,"summary":"This documentation section explains how to use TypeScript to properly type form data and actions in your application. It demonstrates how to define types for form submissions and how to access and work with typed form data within your Svelte components."},{"heading":"Common Form Pitfalls","level":2,"offset":778,"limit":63,"summary":"This documentation section highlights common form pitfalls, such as losing user data on error and issues with multiple forms on a page. It provides solutions by demonstrating how to preserve form data and use named actions for distinct form submissions."}]}
{"index":4,"relative_path":"deployment-guide.md","detailed_summary":"Deploy SvelteKit+Svelte5+Tailwind v4 to production. Guides cover adapter selection (Vercel, Cloudflare, Node, static), platform config, env vars, and CSS optimization.","sections":[{"heading":"Choosing the Right Adapter","level":2,"offset":16,"limit":34,"summary":"To choose the right adapter, consider your deployment target and application needs, such as SSR, edge computing, or static hosting. The documentation provides a comparison table and a decision tree to help you select the most suitable adapter for your project."},{"heading":"Vercel Deployment","level":2,"offset":50,"limit":110,"summary":"This documentation explains how to deploy SvelteKit applications to Vercel by installing the `@sveltejs/adapter-vercel` package and configuring `svelte.config.js` with runtime and region options. It also covers setting environment variables, using a `vercel.json` file for custom configurations, and the deployment process itself."},{"heading":"Cloudflare Pages Deployment","level":2,"offset":160,"limit":106,"summary":"This documentation explains how to deploy SvelteKit applications to Cloudflare Pages by installing the `@sveltejs/adapter-cloudflare` and configuring your `svelte.config.js`. It also details how to handle environment variables, set up build configurations, and deploy using Wrangler, while outlining Cloudflare's specific limitations."},{"heading":"Node Server Deployment","level":2,"offset":266,"limit":138,"summary":"This documentation section explains how to deploy a Node.js server using SvelteKit's adapter-node. It covers installation, configuration, building, running, and deployment options like Docker, Nginx reverse proxy, and PM2."},{"heading":"Static Site Generation","level":2,"offset":404,"limit":98,"summary":"This documentation explains how to use SvelteKit's static site generation (SSG) feature with `@sveltejs/adapter-static` to build static HTML files for deployment on CDNs. It covers installation, configuration, prerendering pages, building, and deploying to platforms like Netlify and GitHub Pages, while also highlighting the correct way to handle data loading for static sites."},{"heading":"Environment Variables","level":2,"offset":502,"limit":76,"summary":"This documentation explains how to manage secrets and configuration using environment variables, categorized by their access scope (private/public) and mutability (static/dynamic). It provides examples for accessing these variables on both server and client sides, and details how to configure them for different deployment platforms like Vercel, Cloudflare, and Node/Docker."},{"heading":"CSS Build Configuration","level":2,"offset":578,"limit":75,"summary":"This documentation section explains how to configure Tailwind CSS for production builds with Vite, emphasizing correct plugin order and CSS import. It also provides troubleshooting tips for CSS loading issues and platform-specific notes on how CSS is handled in production environments like Vercel, Cloudflare, Node, and static deployments."},{"heading":"Platform-Specific Issues","level":2,"offset":653,"limit":60,"summary":"This section addresses common platform-specific issues, including slow Vercel Edge cold starts by switching to the Node.js runtime, Cloudflare response size limits by using streaming, Node server static file serving problems by checking build access and environment variables, and static adapter limitations with dynamic routes by enabling prerendering and specifying entries."},{"heading":"Deployment Checklist","level":2,"offset":713,"limit":48,"summary":"This documentation section provides a comprehensive checklist for deploying a project, covering pre-deployment checks, platform setup, post-deployment verification, and essential monitoring. It also details build commands and output directories for various deployment platforms, with links to further resources for optimization and error handling."}]}
{"index":7,"relative_path":"getting-started.md","detailed_summary":"Get SvelteKit 2, Svelte 5, & Tailwind v4 running in <10 mins. Guide covers environment setup, project creation, Tailwind installation, Vite config, and verification, with common error fixes.","sections":[{"heading":"Prerequisites and Environment Setup","level":2,"offset":14,"limit":36,"summary":"Before proceeding, ensure your environment has Node.js 18.0+ and npm 9.0+ or pnpm 8.0+, along with a modern terminal. If your Node.js version is outdated, install Node 20 LTS using nvm or by downloading it from nodejs.org."},{"heading":"Create New SvelteKit Project","level":2,"offset":50,"limit":64,"summary":"To create a new SvelteKit project with Svelte 5 support, run `npm create svelte@latest my-app` and select the \"Skeleton project\" template, TypeScript, ESLint, Prettier, and crucially, \"Yes\" for the Svelte 5 preview. After installing dependencies with `npm install`, verify the Svelte 5 installation by checking your `package.json` file."},{"heading":"Install Tailwind CSS v4","level":2,"offset":114,"limit":56,"summary":"To install Tailwind CSS v4, use the `@next` tag with npm to install `tailwindcss@next` and `@tailwindcss/vite@next`. Then, add the `@import \"tailwindcss\";` directive to your CSS file."},{"heading":"Configure Vite and Tailwind","level":2,"offset":170,"limit":78,"summary":"To configure Vite and Tailwind, ensure the `tailwindcss()` plugin is placed before the `sveltekit()` plugin in `vite.config.js`. Additionally, import your main CSS file only once in the root `+layout.svelte` file to avoid redundant loading."},{"heading":"Verify Integration Works","level":2,"offset":248,"limit":82,"summary":"This section guides you to verify your integration by starting the development server and testing a Svelte page with Tailwind CSS. It also instructs you to perform a production build to ensure there are no CSS-related errors."},{"heading":"Common Setup Errors","level":2,"offset":330,"limit":77,"summary":"This documentation section outlines common setup errors for a SvelteKit project, including issues with Tailwind CSS installation, Svelte version mismatches, incorrect Vite plugin order, missing CSS imports, file watching conflicts, and TypeScript configuration problems. Each error provides a clear cause and a specific fix, often involving package installations or configuration file adjustments."},{"heading":"Next Steps","level":2,"offset":407,"limit":22,"summary":"This section outlines the next steps after a successful integration, guiding users to learn about Svelte 5 runes, configure their project, style components with Tailwind, build forms, and deploy their application. It also provides a quick reference checklist and directs users to a troubleshooting guide for any issues."}]}
{"index":9,"relative_path":"performance-optimization.md","detailed_summary":"Optimize SvelteKit 2 apps by reducing bundle size (tree-shaking, lazy loading), purging CSS with Tailwind v4, and implementing code splitting. Improve image loading with responsive formats.","sections":[{"heading":"Bundle Size Optimization","level":2,"offset":17,"limit":138,"summary":"This documentation section explains how to optimize JavaScript bundle sizes for faster load times by analyzing your bundle with tools like `rollup-plugin-visualizer`. It also covers techniques such as leveraging tree-shaking, lazy loading heavy dependencies, manual chunk splitting, and removing unused code."},{"heading":"CSS Purging and Minification","level":2,"offset":155,"limit":99,"summary":"Tailwind v4 automatically purges unused CSS, but you can further optimize by configuring content paths, safelisting dynamic classes, and avoiding dynamic class generation. For production, Vite's `lightningcss` minifier and code splitting can reduce CSS bundle size, which should be monitored for efficiency."},{"heading":"Code Splitting Strategies","level":2,"offset":254,"limit":99,"summary":"This documentation section outlines strategies for code splitting, including automatic route-based splitting, lazy loading components on demand, preloading critical routes for faster navigation, and conditionally loading routes based on user authentication. These techniques aim to improve application performance by reducing the initial JavaScript payload."},{"heading":"Image Optimization","level":2,"offset":353,"limit":127,"summary":"This documentation section explains how to optimize images for web delivery by using responsive images with modern formats like WebP and fallbacks. It also provides examples of a reusable `OptimizedImage` component and implementing a blur placeholder for improved user experience."},{"heading":"Font Loading Best Practices","level":2,"offset":480,"limit":69,"summary":"This documentation section outlines best practices for optimizing web font loading. Key strategies include preloading critical fonts with `<link rel=\"preload\">`, defining font display strategies like `swap` or `optional`, implementing system font fallbacks, and leveraging variable fonts to reduce the number of font files."},{"heading":"Lazy Loading Patterns","level":2,"offset":549,"limit":81,"summary":"This documentation section explains how to implement lazy loading for improved performance. It demonstrates using the Intersection Observer API in Svelte to progressively load content as it enters the viewport and also shows how to lazy load images within lists using the `loading=\"lazy\"` attribute."},{"heading":"Preloading and Prefetching","level":2,"offset":630,"limit":79,"summary":"This documentation section explains how to optimize navigation performance in SvelteKit by preloading data for likely routes, either on hover or when the browser is idle. It also demonstrates how to use `data-sveltekit-preload-data` attributes for automatic prefetching on hover or when elements enter the viewport."},{"heading":"Lighthouse Score Optimization","level":2,"offset":709,"limit":49,"summary":"This documentation section outlines strategies for achieving a Lighthouse score of 90+ by optimizing performance through resource hints and critical CSS, preventing layout shifts by specifying image dimensions, and improving third-party script loading with `async` or `defer` attributes. The goal is to enhance user experience and website speed."},{"heading":"Core Web Vitals Checklist","level":2,"offset":758,"limit":58,"summary":"This documentation provides a checklist for optimizing Core Web Vitals, including specific actions for Largest Contentful Paint, First Input Delay, and Cumulative Layout Shift. It also outlines methods for testing these metrics using Lighthouse and monitoring them in production with the `web-vitals` library."},{"heading":"Performance Monitoring","level":2,"offset":816,"limit":48,"summary":"This documentation section explains how to track application performance in production using SvelteKit. It provides code examples for basic performance tracking, including page load times and resource counts, and demonstrates how to integrate these metrics with analytics services."}]}
{"index":8,"relative_path":"migration-svelte4-to-5.md","detailed_summary":"Migrate SvelteKit apps to Svelte 5 with its new rune-based reactivity. This guide covers replacing stores, reactive statements, props, slots, and events. Migrate incrementally.","sections":[{"heading":"Migration Overview","level":2,"offset":17,"limit":30,"summary":"Svelte 5 introduces significant changes like runes replacing stores and a new props syntax, but allows for incremental migration alongside older syntax. The migration process involves updating dependencies, fixing breaking changes, and migrating features incrementally with thorough testing."},{"heading":"Breaking Changes Checklist","level":2,"offset":47,"limit":37,"summary":"This documentation section outlines significant breaking changes in a framework's update, focusing on the reactivity system, component API, event handling, lifecycle, bindings, and TypeScript. Developers must review these changes to ensure their existing code is compatible with the new version."},{"heading":"Stores to Runes Migration","level":2,"offset":84,"limit":162,"summary":"Svelte 5's \"runes\" replace Svelte 4's writable and derived stores, simplifying state management by allowing direct component-level state declaration and manipulation. This migration also introduces a new context pattern for shared state and a class-based approach for custom stores."},{"heading":"Reactive Statements to $derived","level":2,"offset":246,"limit":121,"summary":"In Svelte 5, reactive statements (`$:`) are replaced by `$derived()` for computed values and `$effect()` for statements with side effects. This transition allows for more explicit and performant reactivity management."},{"heading":"Slots and Snippets Migration","level":2,"offset":367,"limit":156,"summary":"This documentation section explains how to migrate from Svelte 4's slot-based composition to Svelte 5's snippet-based approach. The migration involves using `$props()` to declare slot content and `{@render}` to display it, with named slots and slot props now handled via separate snippet functions."},{"heading":"Event Handling Changes","level":2,"offset":523,"limit":114,"summary":"Svelte 5 has changed event handling by migrating from event forwarding to using callback props. This means components now expose props like `onclick` or `oninput` to receive event handlers, and event forwarding syntax has been removed."},{"heading":"Component Lifecycle Updates","level":2,"offset":637,"limit":109,"summary":"Svelte 5 introduces `$effect` as the primary way to handle component lifecycle logic, replacing `onMount`, `beforeUpdate`, and `afterUpdate` with more streamlined and composable patterns. The new `$effect` API also simplifies cleanup by allowing a return function for side effects."},{"heading":"Testing Your Migration","level":2,"offset":746,"limit":64,"summary":"This section emphasizes verifying your Svelte migration by performing component testing, including testing callback props, and following a manual testing checklist to ensure all aspects of your application function correctly. The provided examples show that component testing with `@testing-library/svelte` remains largely the same after migrating to Svelte 5."},{"heading":"Gradual Migration Strategy","level":2,"offset":810,"limit":53,"summary":"This documentation outlines a gradual migration strategy for large SvelteKit applications to Svelte 5. It involves updating dependencies, fixing critical errors, migrating features incrementally based on priority, and thorough testing."},{"heading":"Completed","level":2,"offset":863,"limit":5,"summary":"This section indicates that the Authentication components, Dashboard page, and Settings page have been successfully completed. All listed tasks are marked as finished."},{"heading":"In Progress","level":2,"offset":868,"limit":3,"summary":"This section outlines ongoing development tasks. Currently, the blog feature is in progress, with 3 out of 10 components completed."},{"heading":"Not Started","level":2,"offset":871,"limit":5,"summary":"This section, titled \"Not Started,\" lists two items that have not yet been begun: the Admin panel and the Analytics dashboard. These are presented as a checklist of tasks to be completed."},{"heading":"Troubleshooting Migration Issues","level":2,"offset":876,"limit":110,"summary":"This section addresses common migration issues in Svelte, providing solutions for problems like using `$state` in SSR, circular dependencies, incorrect rendering of children, and effects running too often. It also explains how to ensure form action data correctly updates Svelte runes."},{"heading":"Migration Decision Matrix","level":2,"offset":986,"limit":20,"summary":"This documentation section provides a decision matrix to help determine if a Svelte project is ready to migrate to Svelte 5. It outlines factors like project maturity, team size, and test coverage, suggesting to migrate now for active development with good tests and to wait for stable production with poor tests or tight deadlines. The core advice is to test thoroughly in a separate branch before merging, emphasizing an incremental approach to leverage Svelte 5's new features and backwards compatibility."}]}
{"index":10,"relative_path":"project-setup.md","detailed_summary":"This guide details setting up a SvelteKit project with Svelte 5 and Tailwind v4, covering directory structure, Vite config, TypeScript, and environment variables for scalability.","sections":[{"heading":"Recommended Project Structure","level":2,"offset":14,"limit":102,"summary":"This documentation recommends organizing your project into distinct directories like `src/lib/components`, `src/lib/server`, and `src/routes` to separate concerns and facilitate growth. This structured approach, unlike a flat organization, ensures scalability from prototype to production by grouping code by function and concern."},{"heading":"Vite Configuration Deep Dive","level":2,"offset":116,"limit":104,"summary":"This documentation section provides a comprehensive guide to configuring Vite for optimal development and production builds, emphasizing the importance of a complete `vite.config.js` file. It details various configuration options including CSS, server settings, build optimizations, and path aliases, while highlighting the critical order of plugins."},{"heading":"TypeScript Configuration","level":2,"offset":220,"limit":104,"summary":"This documentation explains how to configure TypeScript for type safety across your SvelteKit stack by providing a complete `tsconfig.json` example. It emphasizes extending SvelteKit's base configuration and includes important settings for module resolution, strict type checking, and path mapping."},{"heading":"Path Aliases and Module Resolution","level":2,"offset":324,"limit":67,"summary":"This documentation explains how to configure path aliases in both `vite.config.js` and `tsconfig.json` to create cleaner, absolute imports in your project. By defining these aliases, you can avoid brittle relative imports and leverage built-in SvelteKit aliases like `$lib`."},{"heading":"Environment Variables Setup","level":2,"offset":391,"limit":87,"summary":"To manage configuration and secrets, create a `.env` file for private variables (ignored by Git) and a `.env.example` file for public variables (committed to Git). Environment variables are then imported into your code based on whether they are public or private, and whether they are needed at build time or runtime."},{"heading":"Development vs Production Config","level":2,"offset":478,"limit":90,"summary":"This documentation explains how to configure different behaviors for SvelteKit development and production environments. You can conditionally set configurations in `svelte.config.js` and `tailwind.config.js` based on the `NODE_ENV` variable, and also detect the runtime environment within Svelte components using `$app/environment`."},{"heading":"Configuration Validation","level":2,"offset":568,"limit":92,"summary":"This documentation section explains how to validate your application's configuration to catch errors early. It provides a script to check for missing environment variables and outlines a checklist for verifying your setup, including Vite, TypeScript, Tailwind, and environment variable loading."}]}
{"index":11,"relative_path":"routing-patterns.md","detailed_summary":"SvelteKit 2 & Svelte 5 offer powerful file-based routing and layout composition with snippets. Explore basic routes, dynamic parameters, loading states with runes, and error handling.","sections":[{"heading":"File-Based Routing Basics","level":2,"offset":16,"limit":65,"summary":"SvelteKit employs file-based routing, where the structure of files within the `src/routes` directory automatically defines your application's routes. Different file types like `+page.svelte` for UI, `+page.server.ts` for server-side data loading, and `+server.ts` for API endpoints are used to build these routes."},{"heading":"Layout Composition with Snippets","level":2,"offset":81,"limit":124,"summary":"Svelte 5 snippets enable flexible layout composition by allowing you to define and render reusable layout components. You can create basic layouts, nest them for more complex structures, and use named snippets to dynamically inject different content into specific layout areas."},{"heading":"Dynamic Routes and Parameters","level":2,"offset":205,"limit":86,"summary":"This documentation explains how to create dynamic routes in your application by using route parameters. You can define single, multiple, optional, or rest parameters within your file-based routing to capture variable parts of URLs and access them in your page's load functions."},{"heading":"Loading States with Runes","level":2,"offset":291,"limit":114,"summary":"This documentation section explains how to handle loading states in Svelte 5 using runes, covering navigation indicators, page-level loading, streaming data, and optimistic navigation. It provides code examples for implementing these features reactively within Svelte applications."},{"heading":"Error Handling in Routes","level":2,"offset":405,"limit":97,"summary":"This documentation explains how to handle errors gracefully in SvelteKit routes by creating a root `+error.svelte` page and throwing errors from `load` functions. It also covers nested error pages for more specific error handling and demonstrates how to implement error recovery within a page."},{"heading":"Nested Layouts Best Practices","level":2,"offset":502,"limit":55,"summary":"Nested layouts help organize complex applications by defining a hierarchical structure for routes, allowing for shared data and UI components across child routes. You can also use layout groups to visually organize, but not affect, the URL structure, and even opt out of parent layouts for specific pages."},{"heading":"Route Organization Strategies","level":2,"offset":557,"limit":83,"summary":"This section outlines strategies for organizing routes in large applications, emphasizing feature-based organization for UI routes and API routes, along with the use of shared components and route guards for maintainability. It also provides a checklist of best practices for effective routing."}]}
{"index":12,"relative_path":"server-rendering.md","detailed_summary":"SvelteKit SSR renders pages on the server. Understand Svelte 5 rune compatibility, use `load` functions for data, and import CSS in `+layout.svelte` to prevent FOUC.","sections":[{"heading":"SSR Fundamentals Review","level":2,"offset":16,"limit":59,"summary":"SvelteKit uses Server-Side Rendering (SSR) to generate HTML on the server and then hydrate it on the client for faster initial rendering and better SEO. However, developers must be mindful of server-only code and ensure client-specific logic is handled appropriately to avoid hydration errors."},{"heading":"Runes and SSR Constraints","level":2,"offset":75,"limit":108,"summary":"This documentation explains how Svelte runes behave during Server-Side Rendering (SSR), highlighting that `$state()` and `$effect()` are client-only, while `$props()` and `$bindable()` are SSR-compatible. `$derived()` runs once on the server for initial rendering and becomes reactive on the client."},{"heading":"Data Loading Patterns","level":2,"offset":183,"limit":105,"summary":"This documentation section explains how to load data in SvelteKit using `load` functions, which can run exclusively on the server or universally on both server and client. The loaded data is then passed as props to your Svelte components, and you can also stream data using promises to improve initial page load performance."},{"heading":"CSS Loading and FOUC Prevention","level":2,"offset":288,"limit":97,"summary":"To prevent Flash of Unstyled Content (FOUC), import your Tailwind CSS in the root layout file (`+layout.svelte`) so it loads before any page renders. Advanced techniques like critical CSS inlining, loading states during hydration, and preloading fonts can further optimize the rendering process."},{"heading":"Hydration Best Practices","level":2,"offset":385,"limit":85,"summary":"To avoid hydration mismatches, ensure server-rendered HTML and client-hydrated HTML are identical by avoiding browser-specific APIs, normalizing dates, and not using random values or client-only state in server-rendered content. If intentional mismatches are necessary, use `data-sveltekit-preload-data=\"off\"` or wrap client-only components in a `{#if browser}` block."},{"heading":"Streaming SSR Considerations","level":2,"offset":470,"limit":76,"summary":"This documentation section explains how to use streaming Server-Side Rendering (SSR) to improve initial page load times by rendering fast data immediately while asynchronously fetching and displaying slower data. It provides code examples demonstrating how to return promises from `load` functions and use Svelte's `{#await}` block to handle loading states with skeleton loaders."},{"heading":"Server vs Client Components","level":2,"offset":546,"limit":63,"summary":"This documentation section explains how to organize code based on where it runs, distinguishing between server-only logic (e.g., database access, API calls) and client-friendly utilities. It also outlines a component organization strategy with `ui`, `client`, and `server` directories to enforce this separation."},{"heading":"SSR Performance Optimization","level":2,"offset":609,"limit":80,"summary":"This documentation section outlines strategies for optimizing server-side rendering (SSR) performance, focusing on reducing Time to First Byte (TTFB). Key techniques include fetching data in parallel, caching expensive operations, lazy-loading components, and prerendering static pages."},{"heading":"Common SSR Errors","level":2,"offset":689,"limit":101,"summary":"This documentation section outlines common Server-Side Rendering (SSR) errors in SvelteKit, such as \"$state is not defined,\" \"localStorage is not defined,\" and hydration mismatches. It provides solutions by emphasizing server-side data hydration, conditional browser API usage, and ensuring consistent rendering between server and client."}]}
{"index":15,"relative_path":"svelte5-runes.md","detailed_summary":"Svelte 5 runes offer fine-grained reactivity but have SSR constraints in SvelteKit. Use `$state()` & `$effect()` client-only. `$derived()` partially works on server. `$props()` & `$bindable()` are SSR-safe. Separate server data loading from client reactivity.","sections":[{"heading":"Runes Overview for SvelteKit","level":2,"offset":16,"limit":50,"summary":"SvelteKit's Runes offer fine-grained reactivity but have strict server-side limitations, with most only functioning on the client. To use them effectively, server data loading must be separated from client-side reactivity, ensuring that runes like `$state()` and `$effect()` are not invoked during server-side rendering."},{"heading":"State Management with $state()","level":2,"offset":66,"limit":99,"summary":"The `$state()` function in Svelte 5 is used to create reactive values that automatically update the UI when they change, supporting primitives, objects, and arrays. It's essential for managing client-side state and can be safely used with server-rendered data by hydrating it."},{"heading":"Derived Values with $derived()","level":2,"offset":165,"limit":88,"summary":"The `$derived()` function in Svelte runes creates computed values that automatically update when their dependencies change, replacing the older reactive statement syntax (`$:`) for this purpose. It can be used for simple calculations or more complex logic with `$derived.by()`, and it runs once on the server for initial rendering and again on the client after hydration."},{"heading":"Side Effects with $effect()","level":2,"offset":253,"limit":112,"summary":"The `$effect()` function in Svelte is used for client-only side effects that should re-run when their reactive dependencies change. It can also handle cleanup logic and has a `$effect.pre()` variant for effects that need to run before DOM updates."},{"heading":"Props and Bindings in Routes","level":2,"offset":365,"limit":81,"summary":"The `$props()` function in SvelteKit routes allows components to receive data from load functions or parent components, supporting basic props, defaults, and destructuring. For two-way data binding, `$bindable()` should be used, and components should avoid directly mutating props by instead creating local state."},{"heading":"Server-Side Constraints (Critical!)","level":2,"offset":446,"limit":88,"summary":"This section emphasizes that server-side rendering (SSR) in SvelteKit has limitations, as certain reactivity features like `$state()` and `$effect()` are unavailable on the server. To avoid errors, developers must separate client-specific logic and ensure that code intended only for the browser is handled appropriately, often by using browser checks or dedicated client-only components."},{"heading":"Migration from Svelte 4 Patterns","level":2,"offset":534,"limit":99,"summary":"This documentation section explains how to migrate Svelte 4 patterns to Svelte 5 runes. It demonstrates converting Svelte 4's writable stores, reactive statements, and lifecycle hooks into Svelte 5's `$state`, `$derived`, and `$effect` runes, respectively, and also shows how event forwarding is replaced by callback props."},{"heading":"Common Runes Mistakes","level":2,"offset":633,"limit":143,"summary":"This documentation section highlights common mistakes when using Svelte runes, such as using `$state` in server-side `.ts` files, forgetting browser guards for client-side APIs, and incorrectly managing props or derived values. It emphasizes using `$props()` for server-loaded data and creating local state for mutations, while also noting that `$effect` automatically tracks dependencies and derived values can often be replaced by simple template expressions."}]}
{"index":13,"relative_path":"styling-patterns.md","detailed_summary":"This guide explores advanced styling with Tailwind CSS v4 & Svelte 5. It covers component patterns (variants, compound), conditional classes using runes, and dynamic styling with CSS custom properties and inline styles for maintainable UIs.","sections":[{"heading":"Component Styling Strategies","level":2,"offset":17,"limit":152,"summary":"This documentation section outlines two strategies for building reusable and consistently styled components: the **variant-based component pattern**, which uses props to control visual variations like color and size, and the **compound component pattern**, which breaks down a complex component into smaller, related sub-components. The variant-based pattern is demonstrated with a `Button` component, while the compound component pattern is illustrated with a `Card` component and its sub-parts."},{"heading":"Conditional Classes with Runes","level":2,"offset":169,"limit":116,"summary":"Svelte 5 runes enable reactive styling through the `class:` directive for boolean conditions and derived state for multiple or complex class logic. This allows for dynamic class application based on component state, including animations and transitions."},{"heading":"Dynamic Styling Patterns","level":2,"offset":285,"limit":121,"summary":"This section explains how to safely handle dynamic styling in Svelte by using CSS custom properties for complex values and inline styles for direct property manipulation. For limited dynamic classes, it suggests a safelist approach with Tailwind CSS to ensure necessary styles are included."},{"heading":"Theme Customization","level":2,"offset":406,"limit":110,"summary":"This documentation explains how to build themeable components using CSS custom properties for defining light and dark themes. It also provides an example of a Svelte component for toggling between these themes and a themeable `Card` component that utilizes the defined theme variables."},{"heading":"Reusable Utility Patterns","level":2,"offset":516,"limit":86,"summary":"This documentation section explains how to create maintainable utility classes using custom definitions in CSS, such as animations, gradients, and effects. These custom utilities can then be easily applied within components for consistent styling."},{"heading":"Design System Integration","level":2,"offset":602,"limit":82,"summary":"This section explains how to integrate a design system by defining design tokens in CSS, such as spacing, typography, and shadows. These tokens are then used within components, like the provided Svelte button example, to ensure consistent styling."},{"heading":"Component Library Patterns","level":2,"offset":684,"limit":64,"summary":"This documentation section outlines patterns for building scalable component libraries, including an \"index pattern\" for exporting components and a \"composable form components\" pattern that uses a `FormField` component to encapsulate common form element logic. These patterns aim to improve organization and reusability within a component library."},{"heading":"Animation and Transition Patterns","level":2,"offset":748,"limit":122,"summary":"This documentation section demonstrates how to create smooth animations and transitions in web applications using custom CSS utility classes for effects like fading, scaling, and sliding. It provides examples of implementing these transitions in components such as modals and dynamic lists."},{"heading":"Common Styling Anti-patterns","level":2,"offset":870,"limit":75,"summary":"This documentation section warns against common styling anti-patterns in Tailwind CSS v4 and Svelte 5, such as overusing `@apply`, dynamically generating classes without full names, using inline styles, neglecting responsive utilities, and inconsistent spacing. It emphasizes adhering to utility-first principles and using Tailwind's built-in features for maintainable and scalable design systems."}]}
{"index":14,"relative_path":"styling-with-tailwind.md","detailed_summary":"Tailwind CSS v4 in SvelteKit/Svelte 5: Simplified config, Vite plugin setup, and CSS import strategies. Learn content detection, component styling, arbitrary values, and dark mode.","sections":[{"heading":"Tailwind v4 Setup Complete","level":2,"offset":16,"limit":59,"summary":"This documentation section outlines the setup for Tailwind v4 using its new Vite plugin architecture. It details the installation process, the correct way to import Tailwind CSS in `app.css` (using `@import \"tailwindcss\";`), and how to configure `vite.config.js` to include the Tailwind plugin before the SvelteKit plugin."},{"heading":"CSS Import Strategies","level":2,"offset":75,"limit":71,"summary":"The recommended CSS import strategy is to place it in the root layout file (`+layout.svelte`) for explicit control and broad availability. Alternatively, CSS can be automatically injected via the Vite configuration, which is less explicit but reduces boilerplate. Avoid importing CSS in individual pages to prevent multiple loads."},{"heading":"Content Detection and Purging","level":2,"offset":146,"limit":91,"summary":"Tailwind CSS needs to be configured to detect classes within Svelte templates, especially for dynamic classes. To avoid purging, use the `class:` directive with full class names or safelist patterns in your `tailwind.config.js`."},{"heading":"Component Styling Patterns","level":2,"offset":237,"limit":120,"summary":"This documentation section advocates for styling reusable Svelte components using Tailwind CSS utility classes directly within the component's script, avoiding `@apply`. It demonstrates patterns like base component styling, prop-based class generation, and a helper function for composing classes."},{"heading":"Arbitrary Values in Templates","level":2,"offset":357,"limit":58,"summary":"This section explains how to use Tailwind's arbitrary value syntax within Svelte templates for custom styling like colors, spacing, and sizes. It also demonstrates how to integrate CSS variables and highlights the correct approach for dynamic values using inline styles rather than template literals within arbitrary value classes."},{"heading":"Dark Mode Implementation","level":2,"offset":415,"limit":87,"summary":"This documentation explains how to implement dark mode in a web application using Tailwind CSS's `class` strategy. It covers configuring Tailwind, creating a toggle component that manages user preferences and applies the `dark` class, and demonstrates how to use dark mode classes and CSS variables for styling."},{"heading":"Custom Utilities and Plugins","level":2,"offset":502,"limit":86,"summary":"Tailwind CSS allows you to extend its functionality by defining custom CSS utilities directly in your stylesheet and by creating custom plugins in your `tailwind.config.js` file. These extensions can also be used to customize the theme with new colors, fonts, and spacing values."},{"heading":"Responsive Design Best Practices","level":2,"offset":588,"limit":63,"summary":"This documentation section outlines best practices for responsive design using Tailwind CSS, emphasizing a mobile-first approach and demonstrating how to implement responsive layouts with modifiers, container queries, and dynamic conditional rendering based on screen size. It showcases examples for adjusting padding, text size, grid columns, and overall layout structures to adapt to different viewport sizes."},{"heading":"Animations with Tailwind","level":2,"offset":651,"limit":72,"summary":"Tailwind CSS allows for animations through built-in classes like `animate-spin` and `animate-bounce`, as well as custom keyframe animations defined in `tailwind.config.js`. You can also create smooth transitions on elements using `transition` utilities and combine them with Svelte's built-in transition directives."},{"heading":"Common Styling Issues","level":2,"offset":723,"limit":78,"summary":"This documentation section addresses common styling issues in SvelteKit with Tailwind CSS, including incorrect plugin order, FOUC, purged dynamic classes, and SSR hydration mismatches. It provides solutions and a debugging checklist to help resolve these problems."}]}
{"index":16,"relative_path":"tailwind-v4-migration.md","detailed_summary":"Migrate Tailwind CSS v3 to v4 in SvelteKit. Key changes: CSS config, new Vite plugin order, updated content detection, and plugin API. Follow the step-by-step guide for a smooth transition.","sections":[{"heading":"Breaking Changes Overview","level":2,"offset":17,"limit":54,"summary":"This documentation section outlines breaking changes in Tailwind CSS v4, primarily affecting configuration, build systems, and CSS imports. Key changes include a shift to CSS-based configuration, a rewritten plugin API, and the mandatory use of the `@tailwindcss/vite` plugin, which requires a specific order in Vite configurations."},{"heading":"Configuration Migration Strategy","level":2,"offset":71,"limit":58,"summary":"Tailwind CSS v4 shifts configuration from JavaScript to CSS, allowing theme customizations and utilities to be defined directly in your CSS files. This approach offers better integration with SvelteKit's Hot Module Replacement (HMR) and reduces the need for a separate JavaScript configuration file unless complex plugins are required."},{"heading":"Content Detection Updates","level":2,"offset":129,"limit":59,"summary":"Tailwind CSS v4 has updated its content detection mechanism, moving configuration from `tailwind.config.js` to CSS files using `@source` and `@utility safe()` directives. This new approach allows for more granular control and automatic detection of classes used in various file types, including SvelteKit-specific patterns."},{"heading":"Syntax Changes in v4","level":2,"offset":188,"limit":43,"summary":"Version 4 maintains core utilities but introduces enhanced syntax for arbitrary values and improved processing for color opacity and important modifiers. It also adds new features like container queries."},{"heading":"Plugin Migration Guide","level":2,"offset":231,"limit":58,"summary":"This guide explains how to migrate custom Tailwind CSS plugins from v3 to v4. For simple utilities, the preferred approach is to use the new CSS `@utility` directive, while JavaScript plugins are recommended for more complex logic or integrations. Popular plugins like forms, typography, and aspect-ratio have v4 equivalents available."},{"heading":"Build Process Changes","level":2,"offset":289,"limit":69,"summary":"To update to Tailwind CSS v4, you need to install the new `@tailwindcss/vite` package, adjust your `vite.config.js` to use the new plugin, and remove any `postcss.config.js` file. The build process itself, as defined in `package.json` scripts, remains unchanged."},{"heading":"Step-by-Step Migration Checklist","level":2,"offset":358,"limit":128,"summary":"This documentation outlines a step-by-step checklist for migrating to Tailwind CSS v4, covering backup, dependency updates, configuration changes, and thorough testing of development and production builds. The process involves updating build configurations, migrating theme extensions and custom utilities to CSS, and ensuring a smooth transition with minimal downtime."},{"heading":"Testing After Migration","level":2,"offset":486,"limit":89,"summary":"After migrating, thoroughly test your application to ensure everything functions correctly. This includes visual regression testing with a dedicated test page, comparing build sizes to confirm optimization, and conducting performance audits using tools like Lighthouse. Additionally, perform cross-browser testing to verify compatibility across different platforms and devices."},{"heading":"Rollback Strategy","level":2,"offset":575,"limit":66,"summary":"This documentation section outlines strategies for safely reverting or partially rolling back a Tailwind CSS migration if it fails. It provides immediate rollback commands, methods for debugging and fixing issues while keeping the migration branch, and suggests a gradual migration approach for complex scenarios."},{"heading":"Common Migration Pitfalls","level":2,"offset":641,"limit":56,"summary":"This section highlights common issues encountered during migrations, such as incorrect Vite plugin order, leftover PostCSS configurations, outdated Tailwind CSS patterns, missing content paths for Tailwind, and adapter compatibility problems. It provides solutions and best practices for each pitfall to ensure a smooth migration process."},{"heading":"Migration Decision Matrix","level":2,"offset":697,"limit":17,"summary":"This documentation section provides a migration decision matrix to help users determine if they should migrate to v4 now. It outlines factors like project stage, plugin usage, and team experience, offering guidance to migrate immediately or wait based on these considerations."},{"heading":"Performance Improvements in v4","level":2,"offset":714,"limit":31,"summary":"Tailwind v4 offers significant performance improvements, including 20-40% faster build times, optimized bundle sizes through dead code elimination and better tree-shaking, and an enhanced development experience with faster HMR and clearer error messages. These optimizations translate to smaller CSS bundles, improved caching, and better browser compatibility in production."}]}
{"index":17,"relative_path":"troubleshooting.md","detailed_summary":"Systematic troubleshooting for SvelteKit + Svelte 5 + Tailwind v4. Covers a 5-step debugging process, binary search, dev server issues, build failures, CSS pipeline problems, and Vite config.","sections":[{"heading":"Systematic Debugging Approach","level":2,"offset":14,"limit":76,"summary":"This documentation outlines a systematic 5-step debugging process: Reproduce, Isolate, Hypothesize, Test, and Fix, to efficiently identify and resolve issues. It also introduces binary search debugging as a method for narrowing down errors when the source is unknown, emphasizing the importance of making one change at a time rather than random modifications."},{"heading":"Dev Server Troubleshooting","level":2,"offset":90,"limit":111,"summary":"This documentation section provides troubleshooting steps for common development server issues, including startup failures, runtime crashes, and Hot Module Reload problems. It offers solutions like checking Node.js versions, resolving port conflicts, clearing caches, reinstalling dependencies, and configuring Vite and SvelteKit settings."},{"heading":"Build Process Debugging","level":2,"offset":201,"limit":94,"summary":"This documentation section provides a systematic approach to debugging production build failures, including steps like cleaning the build, checking TypeScript, enabling verbose logging, and addressing common errors like prerendering failures, Rollup issues, and out-of-memory errors. It also offers methods for testing the production build locally, analyzing bundle size, and testing without a development server."},{"heading":"CSS Pipeline Debugging","level":2,"offset":295,"limit":108,"summary":"This documentation section provides a step-by-step guide to debugging Tailwind CSS issues within a SvelteKit project. It covers common problems like CSS not processing, issues in production builds, incorrect class purging, and how to inspect processed CSS and enable source maps."},{"heading":"Vite Configuration Issues","level":2,"offset":403,"limit":107,"summary":"This documentation section provides a systematic approach to debugging Vite configuration issues. It covers checking config validity, common problems like plugin order and resolve aliases, server configuration options, and how to use logging for debugging."},{"heading":"Using Source Maps Effectively","level":2,"offset":510,"limit":67,"summary":"This documentation explains how to enable and effectively use source maps for debugging in your project. By configuring your build settings and enabling source maps in your browser's DevTools, you can set breakpoints and step through your original code, even when it's been minified or transpiled."},{"heading":"Browser DevTools Strategies","level":2,"offset":577,"limit":91,"summary":"This documentation section outlines strategies for effective browser DevTools debugging, covering console logging, network request analysis, performance profiling, CSS inspection, and testing Server-Side Rendering (SSR). It provides practical steps and code examples for leveraging these tools to identify and resolve issues in web development."},{"heading":"Common Integration Gotchas","level":2,"offset":668,"limit":75,"summary":"This documentation section highlights common integration pitfalls, including issues with asynchronous operations in Svelte's `$state`, the importance of directive order for `class:`, correct usage of Tailwind's `@layer` directive, the necessity of SvelteKit's `fetch` in load functions, and the distinction between public and private environment variables. Understanding these \"gotchas\" can prevent subtle integration problems."},{"heading":"Getting Help Effectively","level":2,"offset":743,"limit":26,"summary":"To get help effectively, first thoroughly search existing resources like GitHub issues, Stack Overflow, and Discord for your problem. If you still need assistance, create a minimal reproduction of your issue with all relevant information, including error messages, package versions, and configuration files."},{"heading":"Description","level":2,"offset":769,"limit":3,"summary":"This documentation section addresses an issue where CSS styles are not loading correctly in the production build of a project. It aims to provide a solution or explanation for this common problem."},{"heading":"Steps to Reproduce","level":2,"offset":772,"limit":5,"summary":"This section outlines the simple steps to reproduce an issue: first, build the project using `npm run build`, then preview it with `npm run preview`, and finally access the preview at `http://localhost:4173`."},{"heading":"Expected Behavior","level":2,"offset":777,"limit":3,"summary":"The documentation section \"Expected Behavior\" states that Tailwind styles should be visible. This means that the styling applied using Tailwind CSS should render correctly and be apparent on the user interface."},{"heading":"Actual Behavior","level":2,"offset":780,"limit":3,"summary":"The page is currently unstyled, meaning it lacks any visual design elements or formatting."},{"heading":"Environment","level":2,"offset":783,"limit":7,"summary":"This documentation section outlines the development environment, specifying versions for SvelteKit, Svelte, Tailwind CSS, Node.js, and the operating system as macOS 14.0. It details the core technologies and their versions used in the project."},{"heading":"Reproduction","level":2,"offset":790,"limit":3,"summary":"This documentation section, titled \"Reproduction,\" provides a link to a GitHub repository at `https://github.com/user/repro`. This repository likely contains the code and instructions necessary to reproduce the results or behavior discussed in the documentation."},{"heading":"Config Files","level":2,"offset":793,"limit":25,"summary":"This documentation section explains how to configure your SvelteKit project using `vite.config.js` and `svelte.config.js`. It also provides resources and a checklist for seeking help with any issues you encounter."}]}
