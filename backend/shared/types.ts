/**
 * Shared TypeScript types across KiteMate backend services
 * 
 * Why this exists:
 * - Provides consistent type definitions across all microservices
 * - Ensures type safety when services communicate
 * - Serves as single source of truth for domain entities
 * - Auto-exported to frontend via Encore TypeScript client generation
 */

// ============================================
// User & Authentication
// ============================================

/**
 * User tier types for subscription management
 */
export type UserTier = 'free' | 'pro';

/**
 * User entity representing a KiteMate account holder
 */
export interface User {
  id: string;
  email: string;
  name: string;
  tier: UserTier;
  queryCount: number;
  queryResetDate: Date;
  username?: string;
  bio?: string;
  avatarUrl?: string;
  followerCount: number;
  totalForksReceived: number;
  zerodhaUserId?: string;
  zerodhaConnected: boolean;
  createdAt: Date;
}

/**
 * Authentication data available in all authenticated endpoints
 */
export interface AuthData {
  userId: string;
  tier: UserTier;
}

// ============================================
// Portfolio
// ============================================

/**
 * Portfolio data source types
 */
export type PortfolioSource = 'zerodha' | 'csv';

/**
 * Asset types supported by KiteMate
 */
export type AssetType = 'equity' | 'mutual_fund' | 'etf' | 'bond';

/**
 * Normalized holding structure (single source of truth)
 * All connectors (Zerodha, CSV) must normalize to this schema
 */
export interface NormalizedHolding {
  symbol: string;
  isin?: string;
  quantity: number;
  avgPrice: number;
  currentPrice: number;
  unrealizedPnL: number;
  assetType: AssetType;
  sector?: string;
  exchange?: string;
  purchaseDate?: string;
  lastTradeDate?: string;
  _metadata?: Record<string, any>;
}

/**
 * Portfolio entity containing all user holdings
 */
export interface Portfolio {
  id: number;
  userId: string;
  source: PortfolioSource;
  lastSync: Date;
  totalValue: number;
  totalPnL: number;
  currency: string;
  holdings: NormalizedHolding[];
  createdAt: Date;
}

/**
 * Portfolio summary for dashboard display
 */
export interface PortfolioSummary {
  totalValue: number;
  totalPnL: number;
  pnlPercentage: number;
  holdingsCount: number;
  topGainers: NormalizedHolding[];
  topLosers: NormalizedHolding[];
  sectorAllocation: Record<string, number>;
}

// ============================================
// Widgets & Dashboard
// ============================================

/**
 * Widget types for visualization
 */
export type WidgetType = 'chart' | 'table' | 'card' | 'tile';

/**
 * Widget visibility settings
 */
export type WidgetVisibility = 'private' | 'public';

/**
 * Chart types for visualization
 */
export type ChartType = 'line' | 'bar' | 'pie' | 'scatter' | 'area';

/**
 * Widget configuration DSL (Domain Specific Language)
 * Generated by LLM from natural language queries
 */
export interface WidgetConfig {
  query: {
    operation: 'aggregate' | 'filter' | 'sort' | 'timeseries';
    field: 'pnl' | 'allocation' | 'returns' | 'holdings' | 'performance';
    filters?: {
      symbol?: string[];
      sector?: string[];
      assetType?: string[];
      minValue?: number;
      maxValue?: number;
    };
    timeRange?: {
      from: string;
      to: string;
    };
    groupBy?: 'sector' | 'assetType' | 'symbol' | 'date';
    sortBy?: string;
    sortOrder?: 'asc' | 'desc';
    limit?: number;
  };
  visualization: {
    chartType?: ChartType;
    xAxis?: string;
    yAxis?: string;
    colors?: string[];
    showLegend?: boolean;
    showGrid?: boolean;
  };
  refresh: {
    automatic: boolean;
    frequency?: 'daily' | 'hourly' | 'manual';
  };
}

/**
 * Widget entity
 */
export interface Widget {
  id: string;
  userId: string;
  title: string;
  type: WidgetType;
  visibility: WidgetVisibility;
  config: WidgetConfig;
  forkCount: number;
  forkedFrom?: string;
  createdAt: Date;
  updatedAt: Date;
}

/**
 * Widget layout position on dashboard
 */
export interface WidgetLayout {
  widgetId: string;
  position: {
    x: number;
    y: number;
    w: number;
    h: number;
  };
  visible: boolean;
}

/**
 * Dashboard configuration
 */
export interface Dashboard {
  userId: string;
  layout: WidgetLayout[];
  updatedAt: Date;
}

// ============================================
// Social Features
// ============================================

/**
 * Notification types
 */
export type NotificationType = 'fork' | 'follow' | 'system' | 'refresh';

/**
 * Notification entity
 */
export interface Notification {
  id: number;
  userId: string;
  type: NotificationType;
  title: string;
  message: string;
  read: boolean;
  metadata?: Record<string, any>;
  createdAt: Date;
}

/**
 * Fork entity tracking widget genealogy
 */
export interface Fork {
  id: number;
  originalWidgetId: string;
  forkedWidgetId: string;
  forkingUserId: string;
  forkedAt: Date;
}

/**
 * Public profile data
 */
export interface PublicProfile {
  username: string;
  name: string;
  bio?: string;
  avatarUrl?: string;
  followerCount: number;
  totalForksReceived: number;
  publicWidgets: Widget[];
  joinedAt: Date;
}

// ============================================
// Subscriptions
// ============================================

/**
 * Subscription status types
 */
export type SubscriptionStatus = 'active' | 'cancelled' | 'past_due';

/**
 * Payment provider types
 */
export type PaymentProvider = 'razorpay' | 'stripe';

/**
 * Billing cycle types
 */
export type BillingCycle = 'monthly' | 'annual';

/**
 * Subscription entity
 */
export interface Subscription {
  id: number;
  userId: string;
  tier: UserTier;
  status: SubscriptionStatus;
  paymentProvider?: PaymentProvider;
  paymentProviderSubscriptionId?: string;
  billingCycle?: BillingCycle;
  amountCents?: number;
  currency: string;
  currentPeriodStart?: Date;
  currentPeriodEnd?: Date;
  cancelAtPeriodEnd: boolean;
  createdAt: Date;
  updatedAt: Date;
}

// ============================================
// Chat & DSL
// ============================================

/**
 * DSL validation result
 */
export type DSLValidationResult = 'valid' | 'invalid';

/**
 * DSL audit log entry
 */
export interface DSLAuditLog {
  id: number;
  userId: string;
  widgetId?: string;
  dslCommand: WidgetConfig;
  validationResult: DSLValidationResult;
  validationErrors?: string[];
  executed: boolean;
  executedAt?: Date;
  createdAt: Date;
}

/**
 * Chat query request
 */
export interface ChatQueryRequest {
  query: string;
  portfolioContext?: Portfolio;
}

/**
 * Chat query response with generated widget
 */
export interface ChatQueryResponse {
  widget: Widget;
  explanation: string;
  suggestedTitle: string;
}

// ============================================
// API Response Wrappers
// ============================================

/**
 * Standard API success response
 */
export interface APIResponse<T> {
  success: true;
  data: T;
}

/**
 * Standard API error response
 */
export interface APIError {
  success: false;
  code: string;
  message: string;
  details?: Record<string, any>;
}

/**
 * Paginated response wrapper
 */
export interface PaginatedResponse<T> {
  items: T[];
  total: number;
  offset: number;
  limit: number;
  hasMore: boolean;
}

